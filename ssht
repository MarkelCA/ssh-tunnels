#!/bin/bash

declare -A tunnel_params
DEFAULT_CONFIG_PATH="$HOME/.config/ssht/ssht.yml"


main() {
    parse_args $@

    # If no file is specified the default file is chosen
    if [ -z "$FILE" ] ; then
        FILE=$DEFAULT_CONFIG_PATH
    fi

    run_command $@
}

parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -f|--file)
                FILE="$2"
                shift # past argument
                shift # past value
            ;;
            -*|--*)
                echo "Unknown option $1"
                exit 3
            ;;
            *)
                POSITIONAL_ARGS+=("$1") # save positional arg
                shift # past argument
            ;;
        esac
    done
}

run_command() {
    command=$1
    case $command in
        "") help::main ;;
        "open")  open_tunnel  ${@:2} ;;
        "close") close_tunnel ${@:2} ;;
        "status") status ${@:2} ;;
        "show") show  ;;
        "list") list  ;;
        "help") help ${@:2}  ;;
        *) 
            echo "Error - Command not found." 
            print_available_commands
        ;;
    esac
}


open_tunnel() {
    if [ ${#POSITIONAL_ARGS[@]} -gt 2 ]; then
        error::too_many_params
    fi

    process_name=$1


    if [ -z $process_name ] ; then
        open_all_tunnels
        exit 0
    fi


    read_config $process_name $FILE

    key=""
    if [ -n "${tunnel_params['ssh_key_path']}" ]; then
        key="-i ${tunnel_params['ssh_key_path']}"
    fi

    ssh_cmd="ssh -N -L ${tunnel_params['port_forward']}:${tunnel_params['host_destination']}:${tunnel_params['port_destination']} ${tunnel_params['user_server']}@${tunnel_params['host_server']} -f $key"
    echo "Running: $ssh_cmd"
    eval $ssh_cmd
}

open_all_tunnels() {
        all_configs=$(yq '.tunnels | keys | .[]' $FILE)
        for config in $all_configs ; do
            open_tunnel $config
        done
}

read_config() {
    process_name=$1
    tunnel_params=()

    while IFS="=" read -r key value; do tunnel_params["$key"]=$value; done < <(
        yq ".tunnels.\"$process_name\" | to_entries | map([.key, .value] | join(\"=\")) | .[]" $FILE
    )

    if [ ${#tunnel_params[@]} -eq 0 ] ; then
        error::process_name_not_found $2
    fi
}
error::process_name_not_found() {
    >&2 echo "Error - The name \"$1\" couldn't be found in the config file."
    echo "Use \"ssht list\" to display the available tunnels."
    exit 1
}


close_tunnel() {
    if [ ${#POSITIONAL_ARGS[@]} -gt 2 ]; then
        error::too_many_params
    fi
    process_name=$1

    if [ -z $process_name ] ; then
        close_all_tunnels
        exit 0
    fi

    cmd="fuser $(get_port_forward $process_name)/tcp -k"
    echo "Running (killing the process_name): $cmd"
    eval $cmd
}

close_all_tunnels() {
    all_configs=$(yq '.tunnels | keys | .[]' $FILE)
    for config in $all_configs ; do
        close_tunnel $config
    done
}

status_all() {
    all_configs=$(yq '.tunnels | keys | .[]' $FILE)
    for config in $all_configs ; do
        echo "- $config:"
        echo "  $(status $config)"
    done
}

get_port_forward() {
    process_name=$1
    yq ".tunnels.\"$process_name\".port_forward" $FILE
}

status() {
    GREEN='\033[0;32m'
    RED='\033[0;31m'
    NC='\033[0m' # No Color

    process_name=$1

    if [ -z $process_name ] ; then
        status_all
        exit 0
    fi

    port=$(get_port_forward $process_name)
    if [[ $port == "null" ]] ; then
        error::process_name_not_found $process_name
    fi

    # We check if the port is from is LISTENING and it's an ssh command
    if [ -n "$(lsof -i tcp:$port | grep 'ssh.*LISTEN')"  ] ; then
        echo -e "${GREEN}open${NC}"
    else
        echo -e "${RED}closed${NC}"
    fi
    
}

show() {
    if [ ${#POSITIONAL_ARGS[@]} -gt 1 ]; then
        error::too_many_params
    fi

    yq $FILE
}

list() {
    if [ ${#POSITIONAL_ARGS[@]} -gt 1 ]; then
        error::too_many_params
    fi

    yq '... comments="" | .tunnels | keys ' $FILE
}

error::too_many_params() {
    >&2 echo "Error - Too many positional params for this command."
    exit 2
}

####################
# HELP FUNCTIONS
####################

help() {
    if [ ${#POSITIONAL_ARGS[@]} -gt 2 ]; then
        error::too_many_params
    fi

    command=$1
    case $command in
        "") help::main  ;;
        "open") help::open  ;;
        "close") help::close  ;;
        "status") help::status  ;;
        "show") help::show  ;;
        "list") help::list  ;;
        "help") help::help  ;;
        *) 
            echo "Error - Command not found." 
            print_available_commands
        ;;
    esac
}

help::main() {
    cat << EOF
Manages SSH tunnels from a YAML configuration.

Usage: 
ssht <command> [-f|--file <file>]

Commands:
    - open [query]    Opens ssh tunnels
    - close [query]   Closes ssh tunnels
    - status [query]  Shows if a tunnel is opened or closed.
    - show            Shows an ssht.yml configuration
    - list            Lists the available tunnels in the configuration
    - help [command]  Shows the help description for a command

Options:
    - -f|--file   The configuration file. Default if none is 
                  provided: ~/.config/ssht/ssht.yml

Help with specific command: 
ssht help <command>

Example: 
ssht help open

For more info visit: https://github.com/markelca/ssh-tunnels#example
EOF
}

help::open() {
    cat << EOF
Opens an ssh tunnel from a YAML configuration given an optional query.

Usage:
ssht open [query] [-f|--file <file>]

The query must match the name of some tunnel in your config file.
If no query is provided it will open all the tunnels available.

Examples:
ssht open remote_database
ssht open private_database -f my-config.yml
EOF
}

help::status() {
    echo "Status help"
    cat << EOF
Shows if a tunnel is opened or closed

Usage:
ssht status [query] [-f|--file <file>]

The query must match the name of some tunnel in your config file.
If no query is provided it will show the status for all the tunnels 
available.

Examples:
ssht status remote_database
ssht status private_database -f my-config.yml
EOF
}
help::close() {
    cat << EOF
Closes an ssh tunnel from a YAML configuration given a specific query.

Usage:
ssht close [query] [-f|--file <file>]

The query must match the name of some tunnel in your config file.
If no query is provided it will close all the tunnels available.

Examples:
ssht close remote_database
ssht close private_database -f my-config.yml

The example above is using the ssht.example.yml config file from the repository.
EOF

}

help::show() {
    cat << EOF
Displays an ssht YAML configuration.

Usage:
ssht show [-f|--file <file>]

Examples:
ssht show
ssht show -f ssht.example.yml
EOF
}

help::list() {
    cat << EOF
Lists the available ssht tunnels from a YAML configuration.

Usage: 
ssht list [-f|--file <file>]

Examples:
ssht list
ssht list -f ssht.example.yml
EOF
}

print_available_commands() {
    cat << EOF
The available commands are:
    - open
    - close
    - status
    - show
    - list
    - help
EOF
}

help::help() {
    cat << EOF
Shows help text for a specific command.

Usage: 
ssht help [command]

Examples:
ssht help
ssht help open
EOF

}

main $@
